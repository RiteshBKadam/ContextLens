package com.riteshbkadam.contextlens;

import com.google.gson.*;
import okhttp3.*;

import java.io.IOException;
import java.time.Duration;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class JavaGeminiClient {
    private static final String GEMINI_URL =
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent";

    // single shared OkHttpClient instance
    private static final OkHttpClient SHARED_CLIENT = new OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .readTimeout(60, TimeUnit.SECONDS)
            .callTimeout(60, TimeUnit.SECONDS)
            .build();

    private final OkHttpClient client;
    private final String apiKey;
    private final Gson gson;

    public JavaGeminiClient(String apiKey) {
        this(apiKey, SHARED_CLIENT);
    }

    // package-private constructor for tests / custom client
    JavaGeminiClient(String apiKey, OkHttpClient client) {
        this.client = client;
        this.apiKey = apiKey;
        this.gson = new GsonBuilder().serializeNulls().create();
    }

    /* -------------------------
       Prompt builders
       ------------------------- */

    private String buildClassificationPrompt(String title, String appName, String pid, String code) {
        // Build JSON-safe prompt by letting Gson escape values when inserted into request JSON.
        return """
                You are a backend logic assistant responsible for classifying and segregating code snippets into their respective projects.

                Each incoming request will include:
                - title: short descriptive title of the file or component
                - appName: the application or project name (if available)
                - pid: unique project identifier (if available)
                - code: the actual code snippet or content

                Your task:
                1. Identify and classify the incoming code:
                   - If metadata (appName or pid) is present, assign the code to that project.
                   - If metadata is missing, analyze the code’s structure, naming conventions, imports, and references to infer which existing project it most likely belongs to.
                   - If it doesn’t match any existing project, classify it as a new project and generate a suggested name (e.g., "AuthModule", "ComposeUI").
                2. Detect code origin:
                   - If copied from AI (contains comments like "Generated by ChatGPT" or placeholders), still associate logically.
                   - If IDE-generated, prioritize metadata and structure.
                3. Return strictly JSON output only, no explanations, like:
                {
                  "projectName": "<identify the project>" IGNORE THE IDE NAME OR ANY PROCESS NAME, INSTEAD GIVE KCTAFVW IN SUCH CASE BUT IT IS NOT PREFERRED TO USE AS DEFAULT VALUE, USE IT ONLY IN SURE CASE FOR EXAMPLE,studio.exe OR idea64.exe,
                  "pid": "<existing or new id>",
                  "fileTitle": "<file title> IGNORE LEADING OR TAILING NAMES e.g. ContextLens � JavaGeminiClient.java SO THE FILE NAME IS ONLY JavaGeminiClient.java THAT MEANS IT'LL BE LIKE filename.ext",
                  "language": "<detected programming language>",
                  "codeOrigin": "<AI | IDE| Unknown>",
                  "classificationType": "<ExistingProject | NewProject | Unclassified>",
                  "confidenceScore": "<0-1>"
                }

                Now analyze the following data:
                title: %s
                appName: %s
                pid: %s
                code:
                %s
                """.formatted(title, appName, pid, code);
    }

    private String buildSnippetSimilarityPrompt(String snippetA, String snippetB){
        return """
            You are a quick code similarity engine. Try to generate response as early as possible.

            Task:
            Compare Snippet A and Snippet B ,
            Snippet A is newly copies snippet by user
            Snippet B consists the existing list of snippets which are already present in system.
            
            return a similarity score between 0 and 1, representing how newly copied snippet i.e. Snippet A is contextually related with the rest of snippets.
            
            Rules:
            - 1.0 = identical or strongly related (same module, class, or feature)
            - 0.0 = completely unrelated
            - Consider purpose, naming, imports, structure, logic, and context.
            - Ignore formatting, whitespace, and minor syntax differences.
            - Output only a decimal number between 0 and 1.
            - No words, no labels, no JSON.
            
            Snippet A:
            %s

            Snippet B:
            %s
            """.formatted(snippetA, snippetB);
    }




    /**
     * Classify a code snippet. Returns the raw text output from the model (expected to be JSON string).
     * You should parse returned JSON with your preferred JSON library (e.g. Gson) externally.
     */
    public String classifyCode(String title, String appName, String pid, String code) throws IOException {
        String prompt = buildClassificationPrompt(title, appName, pid, code);
        return generateText(prompt);
    }

    /**
     * Compare two snippets and return a boolean string ("true"/"false") as interpreted from model output.
     * This method normalizes the model output and returns strictly "true" or "false".
     */
    public double getSimilarityScore(String snippetA, String snippetB) throws IOException {
        String prompt = buildSnippetSimilarityPrompt(snippetA, snippetB);

        String raw = generateText(prompt);

        // Normalize
        String cleaned = raw.trim()
                .replaceAll("[^0-9.]", ""); // keep only digits and decimal point

        if (cleaned.isEmpty()) return 0.0;

        try {
            double score = Double.parseDouble(cleaned);
            if (score < 0) return 0.0;
            if (score > 1) return 1.0;
            return score;
        } catch (NumberFormatException e) {
            return 0.0;
        }
    }


    /* -------------------------
       Networking: request/response
       ------------------------- */

    private String generateText(String prompt) throws IOException {
        // Build the content JSON the way Gemini expects:
        // { "contents": [ { "role": "user", "parts": [ { "text": "<prompt>" } ] } ] }
        JsonObject part = new JsonObject();
        part.addProperty("text", prompt);

        JsonObject content = new JsonObject();
        content.addProperty("role", "user");
        JsonArray parts = new JsonArray();
        parts.add(part);
        content.add("parts", parts);

        JsonArray contentsArray = new JsonArray();
        contentsArray.add(content);

        JsonObject requestBody = new JsonObject();
        requestBody.add("contents", contentsArray);

        RequestBody body = RequestBody.create(requestBody.toString(), MediaType.get("application/json; charset=utf-8"));

        HttpUrl url = HttpUrl.parse(GEMINI_URL).newBuilder()
                .addQueryParameter("key", apiKey)
                .build();

        Request request = new Request.Builder()
                .url(url)
                .post(body)
                .build();

        try (Response response = client.newCall(request).execute()) {
            if (!response.isSuccessful()) {
                String respBody = response.body() != null ? response.body().string() : "<empty>";
                throw new IOException("Unexpected code: " + response.code() + " body: " + respBody);
            }

            String responseBody = response.body() != null ? response.body().string() : "";

            // Parse safely with null checks
            try {
                JsonObject json = gson.fromJson(responseBody, JsonObject.class);
                if (json == null) throw new IOException("Empty JSON response");

                JsonArray candidates = json.has("candidates") ? json.getAsJsonArray("candidates") : null;
                if (candidates != null && candidates.size() > 0) {
                    JsonObject firstCandidate = candidates.get(0).getAsJsonObject();
                    JsonObject contentObj = firstCandidate.has("content") ? firstCandidate.getAsJsonObject("content") : null;
                    if (contentObj != null) {
                        JsonArray partsArr = contentObj.has("parts") ? contentObj.getAsJsonArray("parts") : null;
                        if (partsArr != null && partsArr.size() > 0) {
                            JsonObject partObj = partsArr.get(0).getAsJsonObject();
                            if (partObj.has("text")) {
                                String text = partObj.get("text").getAsString();
                                return normalizeModelText(text);
                            }
                        }
                    }
                }

                // Fallback: try other common locations
                if (json.has("output") && json.get("output").isJsonPrimitive()) {
                    return normalizeModelText(json.get("output").getAsString());
                }

                throw new IOException("No text candidate found in model response. Raw response: " + responseBody);
            } catch (JsonSyntaxException e) {
                throw new IOException("Failed to parse model JSON response: " + e.getMessage() + " raw: " + responseBody, e);
            }
        }
    }

    /* -------------------------
       Helpers
       ------------------------- */


    private String normalizeModelText(String text) {
        if (text == null) return "";
        String s = text.trim();

        // remove surrounding code ticks/backticks and surrounding quotes
        while ((s.startsWith("`") && s.endsWith("`")) || (s.startsWith("\"") && s.endsWith("\""))) {
            s = s.substring(1, s.length() - 1).trim();
        }

        // Remove trailing punctuation produced by model like "true." or "false."
        if (s.equalsIgnoreCase("true.") || s.equalsIgnoreCase("false.")) {
            s = s.substring(0, s.length() - 1);
        }

        // Collapse multiple whitespace/newlines to single space for safer parsing
        s = s.replaceAll("[\\r\\n]+", " ").trim();

        return s;
    }

    private static final Pattern TRUE_FALSE_PATTERN = Pattern.compile("\\b(true|false)\\b", Pattern.CASE_INSENSITIVE);


    private Boolean parseBooleanFromModelOutput(String modelText) {
        if (modelText == null) return null;
        String normalized = modelText.trim();

        // 1) direct strict parse
        if (normalized.equalsIgnoreCase("true")) return Boolean.TRUE;
        if (normalized.equalsIgnoreCase("false")) return Boolean.FALSE;

        // 2) search for a bare true/false token inside text
        Matcher m = TRUE_FALSE_PATTERN.matcher(normalized);
        if (m.find()) {
            String token = m.group(1);
            return Boolean.parseBoolean(token.toLowerCase());
        }

        // 3) no confident boolean found
        return null;
    }
}
